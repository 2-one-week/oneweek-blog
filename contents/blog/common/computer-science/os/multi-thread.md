---
title: Multi Thread
thumbnail: 
date: 2020-08-20 12:00:00
category: CS
tags: [Thread]
draft: false
---

## 멀티 스레드 스케줄링
- 하나의 프로세스에 2가지 이상의 작업을 처리할 수 있는 것

- 동시성 : 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질

- 병렬성 : 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질

### CPU 스케쥴링

Ready Queue나 메인메모리에 여러 프로그램들이 대기 상태에 있을 때, 현재 실행중인 프로세스가 종료되면 다음 프로세스로 어떤 것을 실행시킬지 결정하는 작업을 CPU 스케쥴링이라고 합니다.

- `First-Come, First-Served (= FIFO)`먼저 온 프로세스를 먼저 처리하는 스케쥴링입니다.
- `Shortest-Job-First (SJF)`실행시간이 가장 짧은 것부터 처리하는 스케쥴링입니다.
- `Priority`우선순위가 높은 것부터 처리하는 스케쥴링입니다.
- `Round-Robi (RR)`time quantum(= time slice)이라는 일정 시간을 잡고, 이 시간동안 작업을 실행한 뒤, 다음 작업물로 전환하는 스케쥴링입니다. 이 방식에서는 최적의 time quantum 값을 설정하는 것이 중요합니다.
- `Multilevel Queue`프로세스가 하는 일에 따라 그룹으로 나누고, 이에 따라 여러 개의 큐를 만들어서 각각 큐에 다양한 알고리즘을 적용하는 방식의 스케쥴링입니다.

### 스레드 스케줄링 방식
- 우선 순위 방식 (Priority)
    - 우선 순위가 높은 스레드가 실행 상태를 더 많이 가지록 스케줄링
    - 우선 순위는 시간 제한, 메모리 요구량 등 외부에서 이미 설정된 기준이다.
- 순환 할당 방식 (Round-Robin)
    - 시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식


### Multi Thread Context Switching

**Process란?**

- PC와 Register Set, Process ID, State, 메모리 등의 정보를 가진다.

- 프로세스는 적어도 하나의 Thread를 가진다.

**Thread란?**

- CPU 스케쥴링의 기본 단위.

- Program Counter, Register들과 Stack으로 구성

- Process 내부에서 여러 Thread 생성 가능하며, 코드와 메모리를 공유한다.

**PCB(Process Control Block)**

프로세스를 관리하는 자료구조를 PCB라고 한다. PCB에는 다음과 같은 정보들이 담겨 있다.

- PID

- 프로세스 상태

- 프로그램 카운터

- 스케쥴링 우선순위

- 권한

- 부모와 자식 프로세스

- d프로세스가 존재하는 메모리의 위치를 가리키는 포인터

- 프로세스에 할당된 자원들을 가리키는 포인터

**PCB**
- Process ID와 상태, 우선순위, 메모리 정보 등을 저장한다. 멀티스레드가 아닌 멀티프로세스 환경에서는 PCB가 PC와 Register Set 정보도 포함한다. 여기서는 멀티스레드 환경이라 가정한다.

**TCB**
- Thread별로 존재하는 자료구조이며, PC와 Register Set(CPU 정보), 그리고 PCB를 가리키는 포인터를 가진다.

![TCB 그림](https://blog.kakaocdn.net/dn/sxO0J/btqEwQ5PbRD/krWKDTE60qcaJpksIFcAy1/img.jpg)

TCB는 PCB를 가리키는 포인터를 가진다. 그리고 TCB는 PCB보다 적은 데이터를 가지는 자료구조이다. 해당 Thread에 대한 정보만 저장하면 되기 때문이다.

![TCB 그림 2](https://blog.kakaocdn.net/dn/U3jIY/btqEwH85gqM/skmJtaYqq1MWeyUght7aT0/img.jpg)

TCB가 PCB보다 데이터가 적다

보통 TCB는 커널 레벨에서 Context Switching의 기본 단위가 되며, 같은 프로세스에서의 스위칭에 대해서는 TCB 정보만 저장하면 된다.

하지만 다른 프로세스 간의 스위칭을 할 때에는 PCB / TCB 정보를 모두 저장해야 한다.

![Context Switching 그림](https://blog.kakaocdn.net/dn/zGijd/btqEwhpfF0R/uvjAorkLXwqTXG1j7JE9K0/img.jpg)

독립적인 code, heap, data, stack 영역을 가지는 프로세스와 다르게 스레드는 stack 영역만 별도로 가지기 때문에 context switching 시 그만큼 cost가 적게 든다고 할 수 있다.

### 스레드를 무제한으로 만들수 없다면, 프로세스가 많아질 때 성능 향상을 할 수 있는 방법이 무엇일까?

- 병렬처리를 통하여 하나의 프로그램을 처리해 속도를 향상 시킨다.
- 여러개의 CPU를 두고 각 CPU마다 병렬처리로 스케줄링 하면 처리속도가 올라간다.
    - 그러나 OS구조상 CPU가 2개 이상일 때 사용자 영역의 프로세스들이 커널 스택의 사용을 위해 기다리는 문제가 발생한다.
    - 이를 해결하기 위해 커널 스레드를 구상하여, 커널 스레드가 각자의 스택을 가짐으로써 처리 속도를 향상시킬 수 있다.

### 세마포어 (Semaphore)
현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법

비유 === 화장실에 남는 자리가 표시되는 전광판이 있어서 자리가 있을 때만 들어가는 것.


### 뮤텍스 (Mutex)

한 쓰레드, 프로세스에 의해 소유될 수 있는 **Key**🔑를 기반으로 한 상호배제기법.

공유자원을 사용하려면 **특정 객체(key)를 가진 프로세스/쓰레드만 사용**할 수 있다.

비유) 화장실 열쇠를 가진 사람만 들어갈 수 있다.

### 폰 노이만 구조와 하버드 구조

- 폰 노이만 구조는 내장 메모리의 순차처리 방식으로, 프로그램과 데이터를 하나의 메모리에 저장하여 데이터는 메모리에 읽고 쓸 수 있습니다. 즉, 하나의 버스를 가지고 있으므로, 명령과 데이터가 같은 신호 버스와 메모리를 사용하여 동시 접근이 불가능합니다.폰 노이만 구조는 나열된 명령을 순차적으로 수행하면서 메모리의 값에 접근하는데 이 과정에서 병목현상이 나타나게 됩니다. 이러한 병목현상을 개선한 구조가 하버드 구조입니다.
- 하버드 구조는 명령어와 데이터가 서로 다른 메모리 영역을 차지하며, 메모리 영역마다 주소버스, 데이터 버스, 제어 버스가 따로 존재합니다. 또한 명령어와 데이터를 동시에 접근할 수 있다고 합니다.